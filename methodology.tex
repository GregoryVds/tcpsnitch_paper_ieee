\section{TCPSnitch}\label{sec:tcpsnitch}

Different solutions have been proposed and implemented to analyze the
utilization of system and library calls by applications. Two
approaches are possible. The first one is to analyze the
application code (binary or sometimes source for open-source
applications) and extract the interesting calls from the corresponding
files. Several researchers have adopted this approach to study
networked applications. In 2011,~\cite{Komu:Sockets} analyzed the source
code of 2187 Ubuntu applications to detect the presence of certain keywords
of the socket API. In 2016,~\cite{Tsai:LinuxAPI} disassembled
binaries of 30K Linux applications using \texttt{objdump} and performed
a call-graph analysis to study the Linux API usage. Still in 2016,
~\cite{Atlidakis:POSIX} proposed \texttt{libtrack} and analyzed 1.1M Android
applications for linkage with POSIX functions. The main advantage of this
approach is that it is possible to analyze a large number of applications to
determine the system calls used by the majority of the applications.
Unfortunately, it is very difficult to determine
which parameters are passed to these identified functions or how
frequently they are called. Source code analysis is also impractical for
closed-source applications.

The second approach is to instrument the application and intercept the
system or library calls. On Unix variants, the \texttt{strace} or
\texttt{ltrace} applications can be used to collect traces of the
system or library calls. The \texttt{libtrack} tool proposed by
\cite{Atlidakis:POSIX} also supports dynamic tracing of functions invocations.
\tcpsnitch currently intercepts 40 functions that are related to the network
stack. \tcpsnitch tracks the functions that are applied on each
socket with their timestamp, parameters and return value.
It also collects metadata information such as system information,
the network configuration and the kernel version. Compared to simpler
tools like \texttt{strace} and \texttt{libtrack}, a major benefit of
\tcpsnitch is that all the data collected during the utilization of an
application can be uploaded on a public database. The web interface of this 
database, available on \texttt{https://tcpsnitch.org}, provides different
visualizations of the database and allow users to browse through the
collected traces. \tcpsnitch is written in C and
counts about 6500 lines of code, without blanks and comments.

Compared to the first approach, the main advantage of \tcpsnitch is
that it can trace sequences of calls and also collect information
about the function parameters and the return values. This enables us
to observe how and when socket API calls and options are used, the size of the
buffers used by \texttt{send()/recv()}, which thread called the API function,\ldots
While static analysis tools such as~\cite{Komu:Sockets} or~\cite{Tsai:LinuxAPI}
give indications about the possible usage of some socket API calls or options,
\tcpsnitch allows observing their actual use.

Since \tcpsnitch uses \texttt{LD\_PRELOAD} like \texttt{strace} to intercept
the functions calling the system calls in the standard
C library, it is possible for applications to bypass \tcpsnitch by
either being statically linked with the C library or directly using
the system calls. Before analyzing the results, it is important 
to note one caveat about the utilization of
\tcpsnitch on Android applications. On Android,
applications do not usually call \texttt{exit()} because they typically
remain running or idle once started. To end the tracing of an Android application,
\tcpsnitch calls the \texttt{force-stop} command of the activity
manager tool (\texttt{am}) to terminate the application. This means
that the application does not get the opportunity to cleanly close its
opened sockets. This caveat only affects the interception of the
\texttt{close()} function, not other functions.
